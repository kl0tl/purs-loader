'use strict';

var Promise = require('bluebird');

var fs = Promise.promisifyAll(require('fs'));

var path = require('path');

var jsStringEscape = require('js-string-escape');

var difference = require('lodash.difference');

var debug_ = require('debug');

var debug = debug_('purs-loader');

var debugVerbose = debug_('purs-loader:verbose');

var PsModuleMap = require('./purs-module-map');

function updatePsModuleMap(psModule) {
  var options = psModule.options;

  var cache = psModule.cache;

  var filePurs = psModule.srcPath;

  if (!cache.psModuleMap) {
    debugVerbose('module mapping does not exist - making a new module map');

    cache.psModuleMap = PsModuleMap.makeMap(options.src);

    return cache.psModuleMap;
  } else {
    debugVerbose('module mapping exists - updating module map for %s', filePurs);

    cache.psModuleMap = cache.psModuleMap.then(function (psModuleMap) {
      return PsModuleMap.makeMapEntry(filePurs).then(function (result) {
        var map = Object.assign(psModuleMap, result);

        return map;
      });
    });

    return cache.psModuleMap;
  }
}

// Reference the bundle.
function makeBundleJS(psModule) {
  var bundleOutput = psModule.options.bundleOutput;

  var name = psModule.name;

  var srcDir = psModule.srcDir;

  var escaped = jsStringEscape(path.relative(srcDir, bundleOutput));

  var result = 'module.exports = require("' + escaped + '")["' + name + '"]';

  return Promise.resolve(result);
}

// Replace require and import paths to output files generated by psc with paths
// to purescript sources, which are then also run through this loader.
// Additionally, the imports replaced are tracked so that in the event
// the compiler fails to compile the PureScript source, we can tack on
// any new imports in order to allow webpack to watch the new files
// before they have been successfully compiled.
function makeJS(psModule, psModuleMap, js) {
  var dependencyRE = /(?:require\(|from\s*)['"]\.\.\/([\w\.]+)(?:\/index\.js)?['"]/g;
  var requireRE = /^require/;
  var foreignRE = /(?:require\(|from\s*)['"]\.\/foreign(?:\.js)?['"]/g;

  var name = psModule.name;

  var imports = psModuleMap[name].imports;

  var replacedImports = [];

  var result = js.replace(dependencyRE, function (m, p1) {
    var moduleValue = psModuleMap[p1];

    if (!moduleValue) {
      debug('module %s was not found in the map, replacing dependency with null', p1);

      return 'null';
    } else {
      var escapedPath = jsStringEscape(moduleValue.src);

      replacedImports.push(p1);

      return requireRE.test(m) ? 'require("' + escapedPath + '"' : 'from "' + escapedPath + '"';
    }
  }).replace(foreignRE, function (m) {
    var escapedPath = jsStringEscape(psModuleMap[name].ffi);

    return requireRE.test(m) ? 'require("' + escapedPath + '"' : 'from "' + escapedPath + '"';
  });

  var additionalImports = difference(imports, replacedImports);

  if (!additionalImports.length) {
    return Promise.resolve(result);
  } else {
    var missingImports = additionalImports.filter(function (moduleName) {
      return !psModuleMap[moduleName] && moduleName.split('.')[0] !== 'Prim';
    });

    var updatingPsModuleMap = void 0;
    if (missingImports.length > 0) {
      debug('rebuilding module map due to missing imports for %s: %o', name, missingImports);
      psModule.cache.psModuleMap = null;
      updatingPsModuleMap = updatePsModuleMap(psModule);
    } else {
      updatingPsModuleMap = Promise.resolve(psModuleMap);
    }

    return updatingPsModuleMap.then(function (updatedPsModuleMap) {
      var missingImportsResult = missingImports.map(function (import_) {
        var moduleValue = updatedPsModuleMap[import_];

        if (!moduleValue) {
          debug('module %s was not found in the map, skipping require', import_);

          return null;
        } else {
          var escapedPath = jsStringEscape(moduleValue.src);

          return 'var ' + import_.replace(/\./g, '_') + ' = require("' + escapedPath + '")';
        }
      }).filter(function (a) {
        return a !== null;
      }).join('\n');

      return result + '\n' + missingImportsResult;
    });
  }
}

module.exports = function toJavaScript(psModule) {
  var options = psModule.options;

  var cache = psModule.cache;

  var bundlePath = path.resolve(options.bundleOutput);

  var jsPath = options.bundle ? bundlePath : psModule.jsPath;

  var js = fs.readFileAsync(jsPath, 'utf8').catch(function () {
    return '';
  });

  var psModuleMap = updatePsModuleMap(psModule);

  debugVerbose('loading JavaScript for %s', psModule.name);

  return Promise.props({ js: js, psModuleMap: psModuleMap }).then(function (result) {
    return options.bundle ? makeBundleJS(psModule) : makeJS(psModule, result.psModuleMap, result.js);
  });
};